import axiosAuthClient from '../api/axiosAuthClient';
import { AxiosError } from 'axios';
import {ImageUploadResponse} from "../types/image/ImageUploadResponse.ts";

const API_URL = import.meta.env.VITE_API_URL + '/api/v1/images/';

export const uploadMultipleImages = async (offerId: string, files: File[]): Promise<ImageUploadResponse[]> => {
    const formData = new FormData();
    files.forEach((file) => {
        formData.append('images', file);
    });

    try {
        const response = await axiosAuthClient.post(`${API_URL}${offerId}/upload`, formData, {
            timeout: 30000,
            onUploadProgress: (progressEvent) => {
                if (progressEvent.total) {
                    const percentCompleted = Math.round((progressEvent.loaded * 100) / progressEvent.total);
                    console.log(`ðŸ“Š Upload progress: ${percentCompleted}%`);
                }
            }
        });

        return response.data;
    } catch (error) {
        if (error instanceof AxiosError) {
            if (error.response) {
                const errorMessage = error.response.data?.message ||
                    error.response.data?.error ||
                    `HTTP ${error.response.status}: ${error.response.statusText}`;
                throw new Error(errorMessage);
            } else if (error.request) {
                throw new Error('Brak odpowiedzi z serwera. SprawdÅº poÅ‚Ä…czenie internetowe.');
            } else {
                throw new Error(`BÅ‚Ä…d konfiguracji: ${error.message}`);
            }
        }

        throw new Error('Nieznany bÅ‚Ä…d podczas przesyÅ‚ania zdjÄ™Ä‡');
    }
};

export const uploadMultipleImagesWithoutOffer = async (files: File[]): Promise<ImageUploadResponse[]> => {
    const formData = new FormData();
    files.forEach((file) => {
        formData.append('images', file);
    });

    try {
        const response = await axiosAuthClient.post(`${API_URL}upload`, formData, {
            timeout: 30000,
            onUploadProgress: (progressEvent) => {
                if (progressEvent.total) {
                    const percentCompleted = Math.round((progressEvent.loaded * 100) / progressEvent.total);
                    console.log(`ðŸ“Š Upload progress: ${percentCompleted}%`);
                }
            }
        });

        return response.data;
    } catch (error) {
        if (error instanceof AxiosError) {
            if (error.response) {
                const errorMessage = error.response.data?.message ||
                    error.response.data?.error ||
                    `HTTP ${error.response.status}: ${error.response.statusText}`;
                throw new Error(errorMessage);
            } else if (error.request) {
                throw new Error('Brak odpowiedzi z serwera. SprawdÅº poÅ‚Ä…czenie internetowe.');
            } else {
                throw new Error(`BÅ‚Ä…d konfiguracji: ${error.message}`);
            }
        }

        throw new Error('Nieznany bÅ‚Ä…d podczas przesyÅ‚ania zdjÄ™Ä‡');
    }
};

export const deleteImage = async (imageId: string): Promise<void> => {
    try {
        await axiosAuthClient.delete(`${API_URL}${imageId}`);
    } catch (error) {
        if (error instanceof AxiosError && error.response) {
            throw new Error(error.response.data.message || 'BÅ‚Ä…d podczas usuwania zdjÄ™cia');
        }
        throw new Error('BÅ‚Ä…d sieci podczas usuwania zdjÄ™cia');
    }
};

export const validateImageFile = (file: File): string | null => {
    const allowedTypes = ['image/jpeg', 'image/png', 'image/webp'];
    const maxSizeInMB = 5;
    const maxSizeInBytes = maxSizeInMB * 1024 * 1024;

    if (!allowedTypes.includes(file.type)) {
        return `NieobsÅ‚ugiwany format pliku. Dozwolone formaty: ${allowedTypes.join(', ')}`;
    }

    if (file.size > maxSizeInBytes) {
        return `Plik jest za duÅ¼y. Maksymalny rozmiar: ${maxSizeInMB}MB`;
    }

    return null;
};

export const compressImage = (file: File, maxWidth: number = 1920, quality: number = 0.8): Promise<File> => {
    return new Promise((resolve, reject) => {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        const img = new Image();

        img.onload = () => {
            const ratio = Math.min(maxWidth / img.width, maxWidth / img.height);
            const newWidth = img.width * ratio;
            const newHeight = img.height * ratio;

            canvas.width = newWidth;
            canvas.height = newHeight;

            ctx?.drawImage(img, 0, 0, newWidth, newHeight);

            canvas.toBlob(
                (blob) => {
                    if (blob) {
                        const compressedFile = new File([blob], file.name, {
                            type: file.type,
                            lastModified: Date.now(),
                        });
                        resolve(compressedFile);
                    } else {
                        reject(new Error('BÅ‚Ä…d kompresji obrazu'));
                    }
                },
                file.type,
                quality
            );
        };

        img.onerror = () => reject(new Error('BÅ‚Ä…d Å‚adowania obrazu'));
        img.src = URL.createObjectURL(file);
    });
};